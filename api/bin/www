#!/usr/bin/env node

/**
 * Module dependencies.
 */

const app = require('../app');
const debug = require('debug')('api:server');
const http = require('http');
const db = require('../models');
const Role = db.role;
const User = db.user;
let server = null;

(async function(db, server) {
  console.log("1.main f starts");
const connectDb = async (initial=true)=>{  
  console.log("2.connectDb f starts");
  db.mongoose.Promise = global.Promise;
  const options = {    
    useNewUrlParser: true, 
    useUnifiedTopology: true,
    useFindAndModify: false, 
    useCreateIndex : true ,
    autoIndex: false, // Don't build indexes
    poolSize: 10, // Maintain up to 10 socket connections
    serverSelectionTimeoutMS: 5000, // Keep trying to send operations for 5 seconds
    socketTimeoutMS: 45000, // Close sockets after 45 seconds of inactivity
    family: 4 // Use IPv4, skip trying IPv6    
  };
  try {
    await db.mongoose.connect(db.config.mongoUri, options);
    db.connection = db.mongoose.connection;
    console.log("2.connectDb func step2");
    if (initial){
      console.log("connected");
      startServer();
      initialAsync(db, false);
    }
  } 
  catch (error) {
    console.log('Connect MongoDb Error: ', error);
  }      
  
  return db.mongoose.connection;
  //return db.connection;
};

const startServer = () => {
  /**
  * Get port from environment and store in Express.
  */
  console.log("starting server ...");
  const defaultPort='8080'
  const port = normalizePort(process.env.PORT || defaultPort);
  app.set('port', port);
  /**
  * Create HTTP server.
  */
  server = http.createServer(app);
  /**
  * Normalize a port into a number, string, or false.
  */
  function normalizePort(val) {
    const port = parseInt(val, 10);
    if (isNaN(port)) {
      // named pipe
      return val;
    }
    if (port >= 0) {
      // port number
      return port;
    }
    return false;
}
/**
 * Event listener for HTTP server "error" event.
*/
function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  const addr = server.address();
  const bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}

  /**
  * Listen on provided port, on all network interfaces.
  */
  server.listen(port);
  server.on('error', onError);
  server.on('listening', onListening);

}

async function createAsync(objToCreate, model){
  try{
    await model.create(objToCreate)
  } catch (err) {
    throw new Error(err);        
  }
}

async function initialAsync(db,drop=false) {
  if (!db){
    throw new Error('No dbConnection provided ...');
    return;
  }
  try {
    if(drop){      
      await db.role.collection.drop();
    }
  

    const rolesinDbcount = await db.role.estimatedDocumentCount();
    if (rolesinDbcount === 0){
      await createAsync({name:'user'},db.role);
      console.log("added 'user' to roles collection");
      await createAsync({name:'moderator'},db.role);
      console.log("added 'moderator' to roles collection");
      await createAsync({name:'admin'},db.role);
      console.log("added 'admin' to roles collection");
    }
  } catch (error) {
    console.log("dbError: ", err);
  }
}

connectDb(true).then(()=>{
db.mongoose.connection
.on('error', (err)=>{
  console.log('MongoDb error:', err);
  process.exit();
})  
.on('disconnected', ()=>connectDb(false))
});
})(db,server);  

module.exports = {db, server}